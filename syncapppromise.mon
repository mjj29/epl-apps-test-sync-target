using apama.analyticsbuilder.Promise;
using apama.analyticsbuilder.PromiseJoiner;
using com.softwareag.connectivity.httpclient.HttpTransport;
using com.softwareag.connectivity.httpclient.HttpOptions;
using com.softwareag.connectivity.httpclient.Response;
using com.apama.exceptions.Exception;
using com.apama.util.AnyExtractor;
using com.apama.functional.Fn;
using com.apama.functional.Partial;
using com.apama.functional.Functional;
using com.apama.functional.__Util;
using com.apama.cumulocity.SerialConnection;
using com.apama.cumulocity.FindTenantOptions;
using com.apama.cumulocity.FindTenantOptionsResponse;
using com.apama.cumulocity.TenantOption;
using com.apama.cumulocity.ManagedObject;
using com.apama.cumulocity.Util;
using com.apama.json.JSONPlugin;

event HTTPPromiseHelper
{
	static action create(HttpTransport transport, string base, string auth, any fn) returns action<any> returns any
	{
		log "Create HTTP promise helper";
		HTTPPromiseHelper helper := new HTTPPromiseHelper;
		helper.fn := __Util.getGenericAction(fn);
		helper.bodyfn := __Util.getGenericAction(Fn.partial(constantFn, [new any]));
		helper.transport := transport;
		helper.base := base;
		helper.auth := auth;
		helper.method := "GET";
		return helper.exec;
	}
	static action constantFn(any const, any _) returns any { return const; }
	static action createWrite(HttpTransport transport, string base, string auth, string method, string path, any bodyfn) returns action<any> returns any
	{
		log "Create HTTP promise helper";
		HTTPPromiseHelper helper := new HTTPPromiseHelper;
		helper.fn := __Util.getGenericAction(Fn.partial(constantFn, path));
		helper.bodyfn := __Util.getGenericAction(bodyfn);
		helper.transport := transport;
		helper.base := base;
		helper.auth := auth;
		helper.method := "POST";
		return helper.exec;
	}
	action exec(any a) returns any
	{
		log "HTTP promise helper invoked";
		Promise promise := Promise.create(setupPromise);
		try {
			string nextPath := <string> fn([a]);
			nextPath := nextPath.replaceAll(base, "");
			log "Create an HTTP request for "+nextPath;
			transport.createAndExecuteRequest(method, nextPath, bodyfn([a]), <HttpOptions>Fn.setFields(new HttpOptions, {"headers":{"Accept":"application/vnd.github+json", "Authorization":auth}}), respond);
		} catch (Exception e) {
			log "Got exception in HTTP promise helper "+e.toString();
			exceptPromise(e);
		}
		return promise;
	}
	action setupPromise(action<any> resolve, action<Exception> error)
	{
		resolvePromise := resolve;
		exceptPromise := error;
	}
	action respond(Response r)
	{
		log "Got HTTP response: "+r.payload.data.valueToString();
		resolvePromise(r.payload.data);
	}
	action<sequence<any>> returns any fn;
	action<sequence<any>> returns any bodyfn;
	action<any> resolvePromise;
	action<Exception> exceptPromise;
	HttpTransport transport;
	string base;
	string auth;
	string method;
	any payload;
}

event FileFilter
{
	static action pathMatches(string regex, AnyExtractor data) returns boolean
	{
		return data.getString("path").matches(regex);
	}
	static action entryToFileURL(dictionary<string, string> files, AnyExtractor value)
	{
		files.add(value.getString("path"), value.getString("url"));
	}
	string filter;
	action exec(any tree) returns any
	{
		dictionary<string, string> files := new dictionary<string, string>;
		try {
		Functional(AnyExtractor(tree).getAny("tree"))
			.map(AnyExtractor.create)
			.filter(Fn.partial(pathMatches, filter))
			.map(Fn.partial(entryToFileURL, files));
		} catch (Exception e) {
			log e.toString();
		}
		return files;
	}
}

event GithubPromiseHelper
{
	import "connectivity-base64-codec" as Base64Plugin;
	static action getEntryAndAppend(string entryName, string append, any object) returns string
	{
		return AnyExtractor(object).getStringOr(entryName, "")+append;
	}
	static action getEntry(string entry) returns Partial
	{
		return Fn.partial(getEntryAndAppend, [entry, ""]);
	}
	static action getCurrentTree(HttpTransport transport, string base, string auth, string branch) returns Promise
	{
		return getHead(transport, base, auth, branch).
			andThen(HTTPPromiseHelper.create(transport, base, auth, getEntry("object.url"))).
        	andThen(HTTPPromiseHelper.create(transport, base, auth, Fn.partial(getEntryAndAppend, ["tree.url", "?recursive=1"])));
	}

	static action getEPLFilesFromTree(HttpTransport transport, string base, string auth, string name, Promise tree) returns Promise
	{
		return tree.andThen(FileFilter("epl/"+name+".*").exec);
	}
	static action getHead(HttpTransport transport, string base, string auth, string branch) returns Promise
	{
		return Promise.resolve({"url":"/git/ref/heads/"+branch}).
			andThen(HTTPPromiseHelper.create(transport, base, auth, getEntry("url")));
	}
	static action getFileContents(HttpTransport transport, string base, string auth, string url) returns Promise
	{
		return Promise.resolve({"url":url}).
			andThen(HTTPPromiseHelper.create(transport, base, auth, getEntry("url"))).
			andThen(base64Decode);
	}
	static action writeFileInGit(HttpTransport transport, string base, string auth, string contents) returns Promise
	{
		return Promise.resolve({"content":contents, "encoding":"utf-8"}).
			andThen(HTTPPromiseHelper.createWrite(transport, base, auth, "POST", "/git/blobs", Fn.__identity));
	}
	static action createCommit(any result) returns any
	{
		log "createCommit "+result.valueToString();
		sequence<any> r := <sequence<any>> result;
		return {"message":<any>"Update C8Y", "parents":[AnyExtractor(r[1]).getString("sha")], "tree":AnyExtractor(r[0]).getString("sha"), "author":{"name":"EPL Apps", "email":"automatic.eplapps@streaminganalytics.c8y"}};
	}
	static action createHead(any result) returns any
	{
		log "createHead "+result.valueToString();
		return {"sha":AnyExtractor(result).getString("sha"), "force":true};
	}
	static action createTree(any result) returns any
	{
		log "createTree "+result.valueToString();
		return {"tree": result};
	}
	static action updateTree(HttpTransport transport, string base, string auth, string branch, Promise newtree) returns Promise
	{
		return PromiseJoiner.joinAll([
		    newtree.andThen(HTTPPromiseHelper.createWrite(transport, base, auth, "POST", "/git/trees", createTree)),
		    getHead(transport, base, auth, branch)
		    	.andThen(HTTPPromiseHelper.create(transport, base, auth, getEntry("object.url")))
		]).
			andThen(HTTPPromiseHelper.createWrite(transport, base, auth, "POST", "/git/commits", createCommit)).
			andThen(HTTPPromiseHelper.createWrite(transport, base, auth, "PATCH", "/git/refs/heads/"+branch, createHead));
	}
	static action base64Decode(any a) returns any
	{
		log "base64Decode("+a.valueToString()+")";
		try {
			string content := Base64Plugin.decode(AnyExtractor(a).getString("content"));
			log "Decoded "+content.length().toString()+" bytes";
			return content;
		} catch (Exception e) {
			log e.toString();
		}
		return new any;
	}
}

event EPLFileSyncer
{
	static action createFromManagedObject(HttpTransport http, string base, string auth, string branch, ManagedObject a) returns EPLFileSyncer
	{
		AnyExtractor ae := AnyExtractor(a.params);
		return <EPLFileSyncer> Fn.setFields(new EPLFileSyncer, 
			{"transport": http, "branch":branch, "base":base, "auth":auth, "name":a.name,
			 "eplAppsContent":ae.getStringOr("apama_eplfile.contents", ""),
			 "eplAppsState":ae.getStringOr("apama_eplfile.state", ""),
			 "eplAppsDescription":ae.getStringOr("apama_eplfile.description", "")
			});
	}

	action logAny(any a) returns any
	{
		log a.toString();
		return a;
	}
	action synchronize()
	{
		if eplAppsState != "" {
			// sync EPL to github
			GithubPromiseHelper.getEPLFilesFromTree(transport, base, auth, name, 
			                       GithubPromiseHelper.getCurrentTree(transport, base, auth, branch))
				.andThen(readGitFileContents)
				.andThen(updateGitFileContents)
				.andThen(tryCommitToGit)
				.andThen(completeGitCommit)
				.andThen(logAny);
		}
	}
	action pathNotInCommits(any treeentry) returns boolean
	{
		return -1 = commitPaths.indexOf(AnyExtractor(treeentry).getStringOr("path", ""));
	}
	action updateTree(any tree) returns any
	{
		log JSONPlugin.toJSON(AnyExtractor(tree).getAny("tree"));
		sequence<any> filteredTree := <sequence<any>> Functional(AnyExtractor(tree).getAny("tree"))
			.filter(Fn.isNot(Fn.partial(Fn.fieldEqual, ["type", "tree"])))
			.filter(pathNotInCommits).get();
		integer i := 0;
		while i < commitPaths.size() {
			filteredTree.append({
				"path":commitPaths[i],
				"mode":"100644",
				"type":"blob",
				"sha":commitHashes[i]
			});
			i := i + 1;
		}
		return filteredTree;
	}
	action completeGitCommit(any commit) returns any
	{
		log "completeGitCommit "+commit.valueToString();
		try {
			commitHashes := <sequence<string>> Functional(commit)
				.map(AnyExtractor.create)
				.map(Fn.callAction("getString", "sha"))
				.map(Fn.toType("string"))
				.get();
			
			return GithubPromiseHelper.updateTree(transport, base, auth, branch, GithubPromiseHelper.getCurrentTree(transport, base, auth, branch)
				.andThen(updateTree));
		} catch (Exception e) {
			log e.toString();
		}
		return new any;
	}
	action tryCommitToGit(any _) returns any
	{
		sequence<Promise> promises := new sequence<Promise>;
		if eplAppsState != gitState then {
			log "Updating file state in git" at INFO;
			commitPaths.append("epl/"+name+".state");
			promises.append(GithubPromiseHelper.writeFileInGit(transport, base, auth, eplAppsState));
		} else {
			log "File state already identical in git" at INFO;
		}
		if eplAppsDescription != gitDescription then {
			log "Updating file description in git" at INFO;
			commitPaths.append("epl/"+name+".txt");
			promises.append(GithubPromiseHelper.writeFileInGit(transport, base, auth, eplAppsDescription));
		} else {
			log "File description already identical in git" at INFO;
		}
		if eplAppsContent != gitContent then {
			log "Updating file content in git" at INFO;
			commitPaths.append("epl/"+name+".mon");
			promises.append(GithubPromiseHelper.writeFileInGit(transport, base, auth, eplAppsContent));
		} else {
			log "File content already identical in git" at INFO;
		}
		return PromiseJoiner.joinAll(promises);
	}
	action updateGitFileContents(any gitcontents) returns any
	{
		log "Update git file contents "+gitcontents.valueToString();
		try {
			sequence<any> stringcontents := <sequence<any>> gitcontents;
			gitDescription := <string> stringcontents[0];
			gitState := <string> stringcontents[1];
			gitContent := <string> stringcontents[2];
		} catch (Exception e) {
			log e.toString();
		}
		return new any;
	}
	action readGitFileContents(any gitfiles) returns any
	{
		log gitfiles.valueToString();
		try {
			dictionary<string,apama.analyticsbuilder.Promise> dummy;
			any r := PromiseJoiner.joinAll(<sequence<Promise>>Fn.map(
			            Functional(gitfiles)
			            	.map(Fn.partial(GithubPromiseHelper.getFileContents, [transport, base]))
			            	.get().getEntries()
			            , Fn.toType("apama.analyticsbuilder.Promise")));	
			return r;
		} catch (Exception e) {
			log e.toString();
		}
		return new any;
	}
	HttpTransport transport;
	string base;
	string branch;
	string name;
	string auth;
	string eplAppsContent;
	string eplAppsState;
	string eplAppsDescription;
	string gitContent;
	string gitState;
	string gitDescription;
	sequence<string> commitPaths;
	sequence<string> commitHashes;
}

event GitHandler
{
	static action create(SerialConnection connection, string owner, string repo, string PAT, string branch) returns GitHandler
	{
		return <GitHandler> Fn.setFields(new GitHandler, {
			"connection":<any> connection,
			"repo":"https://api.github.com/repos/"+owner+"/"+repo,
			"auth":"Bearer "+PAT,
			"branch":branch,
			"http":HttpTransport.getOrCreateWithConfigurations("api.github.com", 443, {HttpTransport.CONFIG_TLS: "true", HttpTransport.CONFIG_BASE_PATH: "/repos/"+owner+"/"+repo}),
			"latestHash":[new optional<string>]
			});
	}
	SerialConnection connection;
	string repo;
	string auth;
	string branch;
	HttpTransport http;
	sequence<optional<string>> latestHash;
	
	action startHandler()
	{
		monitor.subscribe(ManagedObject.SUBSCRIBE_CHANNEL);
		log "Synchronizing EPL Apps with "+repo+" branch "+branch;
		on all ManagedObject(type="apama_eplfile") as a {
			log "Got managed object "+a.toString();
			EPLFileSyncer.createFromManagedObject(http, repo, auth, branch, a).synchronize();
		}
		on all ManagedObject(type="c8y_PublicAnalyticsBuilderModel") as a {
			// Do something
		}
		on all wait(10.0) {
			// Do something
		}
	}
}

monitor GitHandlerMonitor {
	constant string ROOT := "/~matj/gittest/";

	action parseData(any a) returns any
	{
		log "Got data "+a.toString();
		return new any;
	}
	action onload()
	{
		SerialConnection connection := SerialConnection.create();
		monitor.subscribe(connection.getChannel(FindTenantOptionsResponse.SUBSCRIBE_CHANNEL));
		
		on FindTenantOptionsResponse(reqId=(<FindTenantOptions>Fn.sendToChannel(connection.getChannel(FindTenantOptions.SEND_CHANNEL), Fn.setFields(new FindTenantOptions, {"reqId":Util.generateReqId(), "category":"github"}))).reqId) as options {
			log "Got option "+options.toString();
			TenantOption opt;
			string owner:="";
			string repository:="";
			string pat:="";
			string branch:="";
			for opt in options.options {
				if opt.key = "owner" { owner:=opt.value; }
				if opt.key = "repo" { repository:=opt.value; }
				if opt.key = "PAT" { pat:=opt.value; }
				if opt.key = "branch" { branch:=opt.value; }
			}
			if owner!="" and repository!="" and pat!="" and branch!="" {
				GitHandler.create(connection, owner, repository, pat, branch).startHandler();
			} else if owner!="" or repository!="" or pat!="" or branch!="" {
				log "You must specify tenant options for github.owner, github.repo, github.branch and github.PAT" at ERROR;
			} else {
				log "Not monitoring for github changes as the options are not configured" at INFO;
			}
		}
/*		
		HttpTransport transport := HttpTransport.getOrCreateWithConfigurations("intra.apama.com", 80, {HttpTransport.CONFIG_BASE_PATH:ROOT});
		Promise.resolve({"next":"start.json"})
			.andThen(HTTPPromiseHelper.create(transport, Fn.getEntry("next")))
			.andThen(HTTPPromiseHelper.create(transport, Fn.getEntry("next")))
			.andThen(HTTPPromiseHelper.create(transport, Fn.getEntry("next")))
			.andThen(parseData);*/
	}
}

using apama.analyticsbuilder.Promise;
using apama.analyticsbuilder.PromiseJoiner;
using com.softwareag.connectivity.httpclient.HttpTransport;
using com.softwareag.connectivity.httpclient.HttpOptions;
using com.softwareag.connectivity.httpclient.Response;
using com.apama.exceptions.Exception;
using com.apama.util.AnyExtractor;
using com.apama.functional.Fn;
using com.apama.functional.Partial;
using com.apama.functional.Functional;
using com.apama.functional.__Util;
using com.apama.cumulocity.SerialConnection;
using com.apama.cumulocity.FindTenantOptions;
using com.apama.cumulocity.FindTenantOptionsResponse;
using com.apama.cumulocity.TenantOption;
using com.apama.cumulocity.ManagedObject;
using com.apama.cumulocity.Util;
using com.apama.json.JSONPlugin;

event HTTPPromiseHelper
{
	static action create(HttpTransport transport, string base, string auth, any fn) returns action<any> returns any
	{
		log "Create HTTP promise helper";
		HTTPPromiseHelper helper := new HTTPPromiseHelper;
		helper.fn := __Util.getGenericAction(fn);
		helper.transport := transport;
		helper.base := base;
		helper.auth := auth;
		return helper.exec;
	}
	action exec(any a) returns any
	{
		log "HTTP promise helper invoked";
		Promise promise := Promise.create(setupPromise);
		try {
			string nextPath := <string> fn([a]);
			nextPath := nextPath.replaceAll(base, "");
			log "Create an HTTP request for "+nextPath;
			transport.createAndExecuteRequest("GET", nextPath, new any, <HttpOptions>Fn.setFields(new HttpOptions, {"headers":{"Accept":"application/vnd.github+json", "Authorization":auth}}), respond);
		} catch (Exception e) {
			log "Got exception in HTTP promise helper "+e.toString();
			exceptPromise(e);
		}
		return promise;
	}
	action setupPromise(action<any> resolve, action<Exception> error)
	{
		resolvePromise := resolve;
		exceptPromise := error;
	}
	action respond(Response r)
	{
		log "Got HTTP response: "+r.payload.data.valueToString();
		resolvePromise(r.payload.data);
	}
	action<sequence<any>> returns any fn;
	action<any> resolvePromise;
	action<Exception> exceptPromise;
	HttpTransport transport;
	string base;
	string auth;
}

event FileFilter
{
	static action pathMatches(string regex, AnyExtractor data) returns boolean
	{
		return data.getString("path").matches(regex);
	}
	static action entryToFileURL(dictionary<string, string> files, AnyExtractor value)
	{
		files.add(value.getString("path"), value.getString("url"));
	}
	string filter;
	action exec(any tree) returns any
	{
		dictionary<string, string> files := new dictionary<string, string>;
		try {
		Functional(AnyExtractor(tree).getAny("tree"))
			.map(AnyExtractor.create)
			.filter(Fn.partial(pathMatches, filter))
			.map(Fn.partial(entryToFileURL, files));
		} catch (Exception e) {
			log e.toString();
		}
		return files;
	}
}

event GithubPromiseHelper
{
	import "connectivity-base64-codec" as Base64Plugin;
	static action getEntryAndAppend(string entryName, string append, any object) returns string
	{
		return AnyExtractor(object).getStringOr(entryName, "")+append;
	}
	static action getEntry(string entry) returns Partial
	{
		return Fn.partial(getEntryAndAppend, [entry, ""]);
	}
	static action getCurrentTree(HttpTransport transport, string base, string auth, string branch) returns Promise
	{
		return getHead(transport, base, auth, branch).
			andThen(HTTPPromiseHelper.create(transport, base, auth, getEntry("object.url"))).
        	andThen(HTTPPromiseHelper.create(transport, base, auth, Fn.partial(getEntryAndAppend, ["tree.url", "?recursive=1"])));
	}

	static action getEPLFilesFromTree(HttpTransport transport, string base, string auth, string name, Promise tree) returns Promise
	{
		return tree.andThen(FileFilter("epl/"+name+".*").exec);
	}
	static action getHead(HttpTransport transport, string base, string auth, string branch) returns Promise
	{
		return Promise.resolve({"url":"/git/ref/heads/"+branch}).
			andThen(HTTPPromiseHelper.create(transport, base, auth, getEntry("url")));
	}
	static action getFileContents(HttpTransport transport, string base, string auth, string url) returns Promise
	{
		return Promise.resolve({"url":url}).
			andThen(HTTPPromiseHelper.create(transport, base, auth, getEntry("url"))).
			andThen(base64Decode);
	}
	static action base64Decode(any a) returns any
	{
		log "base64Decode("+a.valueToString()+")";
		try {
			string content := Base64Plugin.decode(AnyExtractor(a).getString("content"));
			log "Decoded "+content.length().toString()+" bytes";
			return content;
		} catch (Exception e) {
			log e.toString();
		}
		return new any;
	}
}

event EPLFileSyncer
{
	static action createFromManagedObject(HttpTransport http, string base, string auth, string branch, ManagedObject a) returns EPLFileSyncer
	{
		AnyExtractor ae := AnyExtractor(a.params);
		return <EPLFileSyncer> Fn.setFields(new EPLFileSyncer, 
			{"transport": http, "branch":branch, "base":base, "auth":auth, "name":a.name,
			 "eplAppsContent":ae.getStringOr("apama_eplfile.contents", ""),
			 "eplAppsState":ae.getStringOr("apama_eplfile.state", ""),
			 "eplAppsDescription":ae.getStringOr("apama_eplfile.description", "")
			});
	}

	action logAny(any a) returns any
	{
		log a.toString();
		return a;
	}
	action synchronize()
	{
		if eplAppsState != "" {
			// sync EPL to github
			GithubPromiseHelper.getEPLFilesFromTree(transport, base, auth, name, 
			                       GithubPromiseHelper.getCurrentTree(transport, base, auth, branch))
				.andThen(readGitFileContents)
				.andThen(updateGitFileContents)
				.andThen(tryCommitToGit);
		}
	}
	action tryCommitToGit(any _) returns any
	{
		if eplAppsState != gitState then {
			log "Updating file state in git" at INFO;
		} else {
			log "File state already identical in git" at INFO;
		}
		if eplAppsDescription != gitDescription then {
			log "Updating file description in git" at INFO;
		} else {
			log "File description already identical in git" at INFO;
		}
		if eplAppsContent != gitContent then {
			log "Updating file content in git" at INFO;
		} else {
			log "File content already identical in git" at INFO;
		}
		return new any;
	}
	action updateGitFileContents(any gitcontents) returns any
	{
		sequence<string> stringcontents := <sequence<string>> gitcontents;
		gitDescription := stringcontents[0];
		gitState := stringcontents[1];
		gitContent := stringcontents[2];
		return new any;
	}
	action readGitFileContents(any gitfiles) returns any
	{
		log gitfiles.valueToString();
		try {
			dictionary<string,apama.analyticsbuilder.Promise> dummy;
			any r := PromiseJoiner.joinAll(<sequence<Promise>>Fn.map(
			            Functional(gitfiles)
			            	.map(Fn.partial(GithubPromiseHelper.getFileContents, [transport, base]))
			            	.get().getEntries()
			            , Fn.toType("apama.analyticsbuilder.Promise")));	
			return r;
		} catch (Exception e) {
			log e.toString();
		}
		return new any;
	}
	HttpTransport transport;
	string base;
	string branch;
	string name;
	string auth;
	string eplAppsContent;
	string eplAppsState;
	string eplAppsDescription;
	string gitContent;
	string gitState;
	string gitDescription;
}

event GitHandler
{
	static action create(SerialConnection connection, string owner, string repo, string PAT, string branch) returns GitHandler
	{
		return <GitHandler> Fn.setFields(new GitHandler, {
			"connection":<any> connection,
			"repo":"https://api.github.com/repos/"+owner+"/"+repo,
			"auth":"Bearer "+PAT,
			"branch":branch,
			"http":HttpTransport.getOrCreateWithConfigurations("api.github.com", 443, {HttpTransport.CONFIG_TLS: "true", HttpTransport.CONFIG_BASE_PATH: "/repos/"+owner+"/"+repo}),
			"latestHash":[new optional<string>]
			});
	}
	SerialConnection connection;
	string repo;
	string auth;
	string branch;
	HttpTransport http;
	sequence<optional<string>> latestHash;
	
	action startHandler()
	{
		monitor.subscribe(ManagedObject.SUBSCRIBE_CHANNEL);
		log "Synchronizing EPL Apps with "+repo+" branch "+branch;
		on all ManagedObject(type="apama_eplfile") as a {
			log "Got managed object "+a.toString();
			EPLFileSyncer.createFromManagedObject(http, repo, auth, branch, a).synchronize();
		}
		on all ManagedObject(type="c8y_PublicAnalyticsBuilderModel") as a {
			// Do something
		}
		on all wait(10.0) {
			// Do something
		}
	}
}

monitor GitHandlerMonitor {
	constant string ROOT := "/~matj/gittest/";

	action parseData(any a) returns any
	{
		log "Got data "+a.toString();
		return new any;
	}
	action onload()
	{
		SerialConnection connection := SerialConnection.create();
		monitor.subscribe(connection.getChannel(FindTenantOptionsResponse.SUBSCRIBE_CHANNEL));
		
		on FindTenantOptionsResponse(reqId=(<FindTenantOptions>Fn.sendToChannel(connection.getChannel(FindTenantOptions.SEND_CHANNEL), Fn.setFields(new FindTenantOptions, {"reqId":Util.generateReqId(), "category":"github"}))).reqId) as options {
			log "Got option "+options.toString();
			TenantOption opt;
			string owner:="";
			string repository:="";
			string pat:="";
			string branch:="";
			for opt in options.options {
				if opt.key = "owner" { owner:=opt.value; }
				if opt.key = "repo" { repository:=opt.value; }
				if opt.key = "PAT" { pat:=opt.value; }
				if opt.key = "branch" { branch:=opt.value; }
			}
			if owner!="" and repository!="" and pat!="" and branch!="" {
				GitHandler.create(connection, owner, repository, pat, branch).startHandler();
			} else if owner!="" or repository!="" or pat!="" or branch!="" {
				log "You must specify tenant options for github.owner, github.repo, github.branch and github.PAT" at ERROR;
			} else {
				log "Not monitoring for github changes as the options are not configured" at INFO;
			}
		}
/*		
		HttpTransport transport := HttpTransport.getOrCreateWithConfigurations("intra.apama.com", 80, {HttpTransport.CONFIG_BASE_PATH:ROOT});
		Promise.resolve({"next":"start.json"})
			.andThen(HTTPPromiseHelper.create(transport, Fn.getEntry("next")))
			.andThen(HTTPPromiseHelper.create(transport, Fn.getEntry("next")))
			.andThen(HTTPPromiseHelper.create(transport, Fn.getEntry("next")))
			.andThen(parseData);*/
	}
}

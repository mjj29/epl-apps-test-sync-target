
using com.apama.cumulocity.ManagedObject;
using com.apama.util.AnyExtractor;
using com.apama.json.JSONPlugin;
using com.apama.functional.Fn;
using com.apama.functional.Functional;
using com.softwareag.connectivity.httpclient.HttpTransport;
using com.softwareag.connectivity.httpclient.HttpOptions;
using com.softwareag.connectivity.httpclient.Request;
using com.softwareag.connectivity.httpclient.Response;

event Fn2
{
	static action setFields(any evt, any fields) returns any
   {
      if fields.isDictionary() {
         any field;
         for field in fields.getKeys()
         {
            evt.setEntry(field, fields.getEntry(field));
         }
         return evt;
      }

      sequence<string> fieldNames := evt.getFieldNames();
      integer i := 0;
      any field;
      for field in fields.getEntries() {
         evt.setEntry(fieldNames[i], field);
         i := i+1;
      }
      return evt;
   }
    static action isEmpty(any value) returns boolean {
      switch (value as x)
      {
         case listener:    { return x.empty(); }
         case string:   { return x.length()=0; }
         default: {
            if value.empty() { return true; }
            if value.isSequence() or value.isDictionary() or value.getTypeName().find("optional<")=0 { return value.getEntries().size() = 0; }
            return false; // for other types like event etc there is nothing meaningful we can match on the
         }
      }
   }
}

event GitUpdate
{
	static action create(string repo, string auth, string branch, HttpTransport http) returns GitUpdate
	{
		return <GitUpdate> Fn2.setFields(new GitUpdate, [<any>repo, auth, branch, http]);
	}
	string repo;
	string auth;
	string branch;
	HttpTransport http;	
	dictionary<string,string> commit;
	string headcommithash;

	action getWriteResponse(string name, integer requestId) returns integer
	{
		on Response(id=requestId) as r {
			log "Got write response "+r.toString();
			commit[name] := r.payload.getString("sha");
			if commit.size() = 3 { doCommit(); }
		}
		return requestId;
	}
	action writeFile(string name, string data) returns integer
	{
		log "Writing file "+name+" ("+data+")";
		Request r := createRestAPIQuery("POST", "/git/blobs", {"content":data, "encoding":"utf-8"});
		send r to r.channel;
		return r.id;
	}
	action pathNotInCommits(any treeentry) returns boolean
	{
		AnyExtractor ae := AnyExtractor(treeentry);
		return commit.hasKey(ae.getStringOr("path", ""));
	}
	static action createTreeEntry(string path, string hash) returns any
	{
		return { 
			"path": path,
			"mode": "100644",
			"type": "blob",
			"sha": hash
			};
	}
	action doCommit()
	{
		log "Committing to "+repo+": "+commit.toString();
		createRestAPIQuery("GET", "/git/ref/heads/"+branch, new any).execute(getHeadRef);
	}
	action getHeadRef(Response r)
	{
		log "Got response: "+r.toString();
		string headrefhash := r.payload.getString("object.sha");
		string headrefurl := r.payload.getString("object.url");
		createRestAPIQuery("GET", headrefurl, new any).execute(getHeadCommit);
	}
	action getHeadCommit(Response r)
	{
		log "Got response: "+r.toString();
		headcommithash := r.payload.getString("sha");
		string headtreehash := r.payload.getString("tree.sha");
		string headtreeurl := r.payload.getString("tree.url");
		createRestAPIQuery("GET", headtreeurl+"?recursive=1", new any).execute(createTree);
	}
	action createTree(Response r)
	{
		log "Got response: "+r.toString();
		sequence<any> treedata := <sequence<any>> Functional(r.payload.getAny("tree")).filter(Fn.isNot(Fn.partial(Fn.fieldEqual, ["type", "tree"]))).filter(pathNotInCommits).get();
		any _ := Functional(commit).filter(Fn.isNot(Fn2.isEmpty)).map(createTreeEntry).map(treedata.append);
		createRestAPIQuery("POST", "/git/trees", {"tree":treedata}).execute(createCommit);
	}
	action createCommit(Response r)
	{
		log "Got response: "+r.toString();
		string newtreehash := r.payload.getString("sha");
		createRestAPIQuery("POST", "/git/commits", {"message":<any>"Update C8Y", "parents":[headcommithash], "tree":newtreehash, "author":{"name":"EPL Apps", "email":"automatic.eplapps@streaminganalytics.c8y"}}).execute(updateHEAD);
	}
	action updateHEAD(Response r)
	{
		log "Got response: "+r.toString();
		string newcommithash := r.payload.getString("sha");
		createRestAPIQuery("PATCH", "/git/refs/heads/"+branch, {"sha":<any>newcommithash, "force":true}).execute(complete);
	}
	action complete(Response r)
	{
		log "Completed creating commit: "+r.toString();
	}
	action createRestAPIQuery(string method, string path, any content) returns Request
	{
		log "createRequestAPIQuery("+method+", "+path.replaceAll(repo, "")+", "+content.toString()+")";
		Request req := http.createRequest(method, path.replaceAll(repo, ""), content, <HttpOptions>Fn2.setFields(new HttpOptions, {"headers":{"Accept":"application/vnd.github+json", "Authorization":auth}}));
		req.id := integer.incrementCounter("com.softwareag.connectivity.httpclient.HTTPClientGeneric"); 
		return req;
	}
}

event GitHandler
{
	static action create(string owner, string repo, string PAT, string branch) returns GitHandler
	{
		return <GitHandler> Fn2.setFields(new GitHandler, {
			"repo":<any>("https://api.github.com/repos/"+owner+"/"+repo),
			"auth":"Bearer "+PAT,
			"branch":branch,
			"http":HttpTransport.getOrCreateWithConfigurations("api.github.com", 443, {HttpTransport.CONFIG_TLS: "true", HttpTransport.CONFIG_BASE_PATH: "/repos/"+owner+"/"+repo})
			});
	}
	string repo;
	string auth;
	string branch;
	HttpTransport http;

	action updateEPLFile(string name, string contents, string description, string state)
	{
		GitUpdate update := GitUpdate.create(repo, auth, branch, http);
		any _ := Functional({
			"epl/"+name+".mon":contents,
			"epl/"+name+".state": state,
			"epl/"+name+".txt": description
		})
			.map(update.writeFile)
			.map(update.getWriteResponse);
			//.waitForAllCompleted("com.softwareag.connectivity.httpclient.Response", "id", update.doCommit);
	}

	action updateABModel(string name, string model, string description, string state)
	{
		GitUpdate update := GitUpdate.create(repo, auth, branch, http);
		any _ := Functional({
			"model/"+name+".json": model,
			"model/"+name+".state": state,
			"model/"+name+".txt": description
		})
			.map(update.writeFile)
			.map(update.getWriteResponse);
			//.waitForAllCompleted("com.softwareag.connectivity.httpclient.Response", "id", update.doCommit);
	}

	action startHandler()
	{
		monitor.subscribe(ManagedObject.SUBSCRIBE_CHANNEL);
		on all ManagedObject(type="apama_eplfile") as a {
			AnyExtractor ae := AnyExtractor(a.params);
			updateEPLFile(a.name, ae.getStringOr("apama_eplfile.contents", ""), ae.getStringOr("apama_eplfile.description", ""), ae.getStringOr("apama_eplfile.state", "")); 
		}
		on all ManagedObject(type="c8y_PublicAnalyticsBuilderModel") as a {
			AnyExtractor ae := AnyExtractor(a.params);			
			updateABModel(a.name, JSONPlugin.toJSON(a.params.getOr("builderModel", new dictionary<any, any>)), ae.getStringOr("description", ""), JSONPlugin.toJSON({"mode":ae.getStringOr("mode", ""), "modeProperties":ae.getStringOr("modeProperties", ""), "state":ae.getStringOr("state", "")}));
		}
	}

}

monitor GitHandlerMonitor {
	action onload() {
		GitHandler.create("mjj29", "epl-apps-test-sync-target", "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", "main").startHandler();
	}
}